Finished:
---------
Graphhopper web
----------------
1. on the client side, A dropdown listbox has been added to the webpage that allows the user to select preferred weighting; i.e fastest, shortest.
2. on the server side, Based on available sensor data for each city, appropriate config file is read (by checking the opened city map). This information is sent to the client, and the weighting dropdown list is amended accordingly with available sensors weighting options; e.g. least_noisy
3. On the client side, the URL query is amended to include weighting (its value is taken from the value selected by the user), and vehicle, which is read from config.properties.
4. On the client side, If the user entered the query directly from the URL, e.g. (http://localhost:9000/?point=Tallaght&point=Blackrock&vehicle=car&weighting=shortest&locale=en-US), the params values from the query are propagated to corresponding DOM elements!
5. Routing is done if the user selects 'shortest' by calling relevant encoder (only fastest was implemented)
6. write a program in java that populates all Dublin Edges with random noise values (from 0-80) for testing purposes (Done! please refer to point
    8 for imp. required changes in the Python code)

7. Graphhopper: Building noise encoder that accesses noise readings from redis and returns the path with min total noise.
   -> Actually NoiseWeighting, not encoder. Encoder is per Vechile, e.g. CarFlagEncoder, BikeFlagEnclder...etc, and is only used when
      calculating the 'fastest' route (weighting is set to 'fastest') because the minimization of time will depond on the speed of every
      vechile. For shortest and LeastNoisy, only distance matters!
   -> NoiseWeighting has been implemented that implements 'Weighting' and is linked to 'least-noisy' weighting (passed from the web page) 

8. IMPORTANT NOTES: Graphhopper generates a graph from the OSM map (a set of bytecode files;e.g. edges, nodes, names...etc.). During the generation process, it makes many 
   simplification (merging/removing edges nodes), and more importantly, changing the ids of the edges. They dont keep any link belween the concrete edgeID 
   (OSM edgeID) and internal graph edgeID (as far as I have looked). The only meaningful information we can get from the graph is the 'name' of the graph edge.
   Please note that Graph edgeID maps to many OSM edgeIDs, however this relationship is not maintained. Therfore, there is no way to retrieve noise readings
   from Redis by OSM edgeID. What I have done in '6' is that I got the 'edgeName' from graphhopper, which is a concatenation between 'name' tag and 'ref' tag
   in every way; e.g.'Butt Bridge, R802', 'Cardiffsbridge Road, R103', 'Cardiffsbridge Road, R108'. You can notice here that the 'name' is not unique, however,
   the combination of 'name' and 'ref' is unique on the graph level, but not on the OSM level
  
   Therefore, to be able to retrieve noise readings, keys should be formatted as follows: city_readingType_edgeName[_ref]. 
   The reason why we need 'city' and 'readingType' is described below. 'name' and 'ref' are not unique for GH (however they are unique to the internal graph
   representation by eliminating street number -if exists-), when parsing the OSM map to get the values of 'name' and 'ref' of a specific 'edgeID', and if
   this key combination exists in Redis, an average of the stored reading and the new noise reading maybe calculated (that's how I implmeneted it in 6). In 6
   I first used Osmosis to filter Dublin map to show only Ways, then I started parsing the xml file (to improve the performance). In the OSM map, each way
   should have a 'name', but may not have a 'ref'. so, 'ref' is optional, and a key without a ref should be like: city_readingType_edgeName 
   
   city_readingType is required in Redis keys because Redis doesn't have a way to rename DBs, and by default everything is stored/retrieved from db0, so
   there should be a way to distinguish which city each key belongs to, and which noise readings it store. for example, we might have 
   'dublin_noise_Abbey Street', 'dublin_air_Abbey Street', 'paris_noise_Abbey Street' (street names are not unique from city to another), so there should be
   a way to ditinguish between them. Having said that, Python code needs to be changed as described in point '1' in TODO list below.     
    



TODO:
----

1. Required changes in Python code: 
   There is no way in Redis to change the database name, so that it can carry the city name and the type
  of readings to be able to connect to the appropriate database during routing to capture relevant sensor readings. Here we assume that 
  every city+sensor reading type is stored in a separate database. Another solution is to store everything in the same database, 
  but the keys of the hashes should carry the type of the reading; i.e. city_readingType_edgeName_[ref] (check point 8 above). city is coming from the name 
  of the map (first token; e.g. dublin-m50.osm), readingType is coming from the city config file (type field). We should standardize the name of the readings
  for all cities; e.g. noise, air...etc., which is important during routing. These are the steps I followed when I implemented 6: 

  a. Filter the relevant map to generate another dump map with only 'Ways'; e.g. 'dublin-ways.osm'
  b. Do the Python magic (Vivek's magic:)) to retrieve affected edges given a propagation value...etc.
  c. for each edgeId from 'b', retrieve corresponsing 'name' and 'ref' (if exists) from 'dublin-ways.osm', and build the Redis key as 
     city_readingType_edgeName[_ref] ([_ref] is optional). When parsing a new sensor file, all old readings in redis should be overwritten. But the point 
     here is that in the same sensor file, there might be the case that two or more different OSM edgeIds, having the same edgeName[_ref].   
     So, we need to decide whether to overwrite or get their average. In 6, I calculated their average. 
  d. The name of the fields inside each hash should be 'type' and 'timestap'. for example, 'noise' and 'timestamp'. This is important in routing. 
  e. We might still need to keep track of OSM edgeIds (dont know why, but we would need it:)), so, in addition to 'noise' and 'timestamp', we might have a set,
     for example named as 'edgeIds' storing the edges of this key.

  f. PROBLEM WITH REDIS: During routing, the routing algorithm calls the relevant Weighting (e.g. LeastNoisyWeighting) for each edge it's examining to minimize the desired weighting.
     for example, if 'Weighting = fastest', the algorithm minimizes the time, if if 'Weighting = fastest', the algorithm minimizes the distance. Now, if
     'Weighting = least-noisy', the algorithm minimizes the the noise-readings. The algorithim calls for noise readings hunderads of time, after sometime, 
      Redis rejects the connection and raises 'JedisConnectionException: java.net.SocketException: Connection reset'. It's important for this problem to
      be solved in order to get real results! For now, I am returing an average value of 30 if the noise-reading doesnt exist for this street, 
      or the connection with Reids is rejected!
  g. ANOTHER PROBLEM we can live it for now, 'least-noisy' calculation is slower than 'fastest' and 'shortest', because we rely on Redis. An alternative,
     to the Redis solution is that We might consider *again* amending the OSM map with new tags and retrieving them from the graph 
     (have no idea how they manipulate bytecode!).

 
2. If Bike or Foot is specificed in 'acceptWay' in config file, the user to be provided the option to specify 'Elevation' Yes or NO
   -> elevation is equals false by default

3. Instruction list should also include noise readings on different segments when least-noise weighting is selected, which are displayed with the reading
   timestamp.


4. When routing based on the noise readings, shall we take distance into consideration, the algorithm might return a very long route
   just because it's the least noisy. A solution could be to have two weighting: 'least_noisy' that takes distance into account, and
   abolute-least-noisy' that just cares about noise--To BE DISCUSSED

5. If more than one vechile is specified in "osmreader.acceptway" in config.properties, the aplication raises an exception when it runs; i.e "Multiple encoders are active, can't return one". currently, only one vechile type is accepted; car,foot,bike,mtb,racingbike.
   -> This exception is actually coming from EncodingManger when encodingManager.getSingle() is called inside route() inside graphhopper
   -> Also check getVehicleCount() inside encodingManager()
   -> Maybe this could be solved by defining another method similar to getSingle() that returns multiple FlagEncoder corresponding to
      the values specified in osmreader.acceptWay

------------------------------------------------------------------------------------------------------------------------------
Miscellaneous
-------------


6. Investigate with heatmap on the visualization of noise readings on the map! would be cool:)


7. Generate an Andriod app out of the Netbeans project


8. in LeastNoisyWeighting, check what calls getMinWeight() method, and what it's needed for 


9. Graphhopper noise routing: Check Chweighting which is called by other algorithms to see if NoiseWeightig needs to be incorporated by anyway, probably
   this is also related to 8.




